Opstart
skal starte med klasse deklaration
.class public super main
  main er navnet
  super betyder den ikke nedarver fra andre

skal slutte dem med
.sourcefile 'navn.java'
.end class


alle klasser skal muligvis have en init metode:
.method public <init> : ()V
  .code stack 1 locals 1
    aload_0 //ved ikke om er nødvendigt, men var i eksempel
    invokespecial Method java/lang/object <init> ()V //siger den skal bruge pakken java/lang/object ???
    return
  .end code
.end method


først declare metode, og deklare kode stakken og dens locals(scope)
eksempel: main metode
.method public static main : ([Ljava/lang/String;)V
  .code stack 1 locals 2

  .end code
.end method

.method indikere det er en metode
main er navnet
([Ljava/lang/String;)V
[ indikere array
  java/lang/String er typen
V indikere void

.code indikere initialition stak of scope
stack 1 locals 2 fortæller hvilken stack og hvilket scope den er i

klasse



Almindelige variabler
  
dconst_x smider konstanten x på nuværende stack
dstore_x smider første double på nuværende stack ind i plads x i nuværende array


Egne arrays


laver et nyt array via newarray T_DOUBLE //floats er T_FLOAT, long er T_LONG etc

eksempel lave array

ldc //størrelse
newarray T_DOUBLE
astore x //x er hvor array referencen skal placeres

loader via:
  aload x 
  ldc y 
  daload

Først loader den en array reference fra pladsen i lokale array x
så sætter den en konstant y på stacken, som siger på hvilken plads den skal hente
til sidst så tager daload y og x og sætter værdien x[y] på stakken

Simple operationer

//hvis har flere operationer, så bare lad vær med at store i de enkelte trin

addition
  dload_//variabel
  dload_//variabel
  dadd
  dstore_//hvilken den skal gemme til

subtraktion
  dload_//variabel
  dload_//variabel
  dsub
  dstore_//hvilken den skal gemme til

multiplication
  dload_//variabel
  ..
  dmul
  dstore_//variablen

division
  ddiv

modulo
  drem

negation
  dneg
  

Sammenligninger

dcmp<op>
  hvis lig med hinanden så smider den nul
  hvis den øverste værdi er større end den under, så smider den 1
  hvis den nederste værdi er større end den over, så smider den -1
<op> bestemmer hvordan den håndtere NaN (Not a Number)
  dcmpg pusher 1 
  dcmpl pusher -1
  
Metoder

kig i opstart for hvordan deklare en metode

retur typer
  V = void
  D = double //kvalificeret gæt


kalder metoder via:
  invokestatic klassenavn/metodenavn(variablerkankaldemed;)Returtype
eksempel:
  invokestatic main/main(Ljava/lang/String;)V

if løkker

ifeq<label> = hvis top stack lig 0
ifne<label> = hvis top stack lig !0
iflt<label> = hvis top stack < 0
ifle<label> = top stack <= 0
ifgt<label> = top stack > 0
ifge<label> = top stack >= 0

gentag løkke (når der er ingen operationer på værdierne inde i løkken)

dload_//anden værdi
dload_//første værdi
dup2_x2
dup2_x2 //så ikke behøve hente fra memory hver gang
dcmpl
iflt label //virker det sådan?
//fjerner variablerne
pop2
pop2

label:
  //sætter værdien 1 til den første, duplikere den og gemmer den
  dconst_1
  dadd
  dup2  
  dstore_//første værdi
  {linjer}
  dup2_x2
  dup2_x2
  dcmpl
  iflt label

gentag løkke (når der er operationer på værdierne i løkken)

dload_//anden værdi
dload_//første værdi
dcmpl
iflt label //virker det sådan?
//fjerner variablerne
pop2
pop2

label:
  {linjer}
  dload_//anden værdi
  dload_//første værdi
  dconst_1
  dadd
  dup2
  dstore_//første værdi
  dcmpl
  iflt label


while løkke


//laver en masse sammenligniner
//værdien skal være nul for at den køre med ifeq
ifeq label


label:
  {linjer}
  //alle de samme sammenligniner
  ifeq label
